const mongoose = require('mongoose');

const analyticsSchema = new mongoose.Schema({
  reportId: {
    type: String,
    required: [true, 'Report ID is required'],
    unique: true
  },
  reportType: {
    type: String,
    enum: ['daily', 'weekly', 'monthly', 'quarterly', 'annual', 'custom'],
    required: [true, 'Report type is required']
  },
  generatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Generated by user is required']
  },
  dateRange: {
    startDate: {
      type: Date,
      required: [true, 'Start date is required']
    },
    endDate: {
      type: Date,
      required: [true, 'End date is required']
    }
  },
  scope: {
    cityWide: { type: Boolean, default: false },
    districts: [String],
    routes: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Route'
    }],
    wasteTypes: [{
      type: String,
      enum: ['general', 'recyclable', 'organic', 'hazardous', 'electronic']
    }]
  },
  collectionMetrics: {
    totalCollections: { type: Number, default: 0 },
    completedCollections: { type: Number, default: 0 },
    missedCollections: { type: Number, default: 0 },
    averageCollectionTime: { type: Number, default: 0 },
    collectionEfficiency: { type: Number, default: 0 },
    onTimePercentage: { type: Number, default: 0 }
  },
  wasteMetrics: {
    totalWeight: { type: Number, default: 0 },
    totalVolume: { type: Number, default: 0 },
    wasteByType: [{
      type: String,
      weight: Number,
      volume: Number,
      percentage: Number
    }],
    recyclingRate: { type: Number, default: 0 },
    divertedFromLandfill: { type: Number, default: 0 },
    contaminationRate: { type: Number, default: 0 }
  },
  routeMetrics: {
    totalRoutes: { type: Number, default: 0 },
    completedRoutes: { type: Number, default: 0 },
    averageRouteTime: { type: Number, default: 0 },
    fuelConsumption: { type: Number, default: 0 },
    distanceCovered: { type: Number, default: 0 },
    routeEfficiency: { type: Number, default: 0 }
  },
  financialMetrics: {
    totalRevenue: { type: Number, default: 0 },
    operationalCosts: { type: Number, default: 0 },
    profitMargin: { type: Number, default: 0 },
    averageRevenuePerUser: { type: Number, default: 0 },
    paymentComplianceRate: { type: Number, default: 0 },
    overduePayments: { type: Number, default: 0 }
  },
  environmentalMetrics: {
    carbonFootprint: { type: Number, default: 0 },
    fuelSaved: { type: Number, default: 0 },
    emissionsReduced: { type: Number, default: 0 },
    waterSaved: { type: Number, default: 0 },
    energySaved: { type: Number, default: 0 }
  },
  userMetrics: {
    totalUsers: { type: Number, default: 0 },
    activeUsers: { type: Number, default: 0 },
    newRegistrations: { type: Number, default: 0 },
    userSatisfactionScore: { type: Number, default: 0 },
    complaintsReceived: { type: Number, default: 0 },
    complaintsResolved: { type: Number, default: 0 }
  },
  trendAnalysis: {
    wasteGrowthRate: { type: Number, default: 0 },
    seasonalPatterns: [{
      month: Number,
      avgWeight: Number,
      avgVolume: Number,
      collections: Number
    }],
    peakHours: [{
      hour: Number,
      collections: Number,
      efficiency: Number
    }],
    predictions: {
      nextMonthWaste: { type: Number, default: 0 },
      requiredCapacity: { type: Number, default: 0 },
      recommendedRoutes: { type: Number, default: 0 }
    }
  },
  alerts: [{
    type: {
      type: String,
      enum: ['high_contamination', 'missed_collections', 'route_inefficiency', 'cost_overrun', 'capacity_shortage']
    },
    severity: {
      type: String,
      enum: ['low', 'medium', 'high', 'critical']
    },
    message: String,
    affectedAreas: [String],
    actionRequired: String
  }],
  recommendations: [{
    category: {
      type: String,
      enum: ['route_optimization', 'capacity_planning', 'cost_reduction', 'efficiency_improvement', 'environmental']
    },
    priority: {
      type: String,
      enum: ['low', 'medium', 'high']
    },
    description: String,
    expectedImpact: String,
    implementationCost: Number,
    timeframe: String
  }],
  status: {
    type: String,
    enum: ['generating', 'completed', 'failed', 'archived'],
    default: 'generating'
  },
  generationTime: {
    type: Number,
    default: 0
  }
}, {
  timestamps: true
});

analyticsSchema.pre('save', function(next) {
  if (!this.reportId) {
    const timestamp = Date.now();
    const random = Math.floor(Math.random() * 1000);
    this.reportId = `RPT-${timestamp}-${random}`;
  }
  next();
});

analyticsSchema.methods.calculateEfficiencyMetrics = function() {
  if (this.collectionMetrics.totalCollections > 0) {
    this.collectionMetrics.collectionEfficiency = 
      (this.collectionMetrics.completedCollections / this.collectionMetrics.totalCollections) * 100;
  }
  
  if (this.routeMetrics.totalRoutes > 0) {
    this.routeMetrics.routeEfficiency = 
      (this.routeMetrics.completedRoutes / this.routeMetrics.totalRoutes) * 100;
  }
  
  if (this.financialMetrics.totalRevenue > 0) {
    this.financialMetrics.profitMargin = 
      ((this.financialMetrics.totalRevenue - this.financialMetrics.operationalCosts) / 
       this.financialMetrics.totalRevenue) * 100;
  }
};

analyticsSchema.methods.generateAlerts = function() {
  this.alerts = [];
  
  if (this.collectionMetrics.collectionEfficiency < 80) {
    this.alerts.push({
      type: 'missed_collections',
      severity: 'high',
      message: 'Collection efficiency below acceptable threshold',
      actionRequired: 'Review route planning and resource allocation'
    });
  }
  
  if (this.wasteMetrics.contaminationRate > 15) {
    this.alerts.push({
      type: 'high_contamination',
      severity: 'medium',
      message: 'Contamination rate exceeds target levels',
      actionRequired: 'Implement additional waste education programs'
    });
  }
  
  if (this.routeMetrics.routeEfficiency < 75) {
    this.alerts.push({
      type: 'route_inefficiency',
      severity: 'medium',
      message: 'Route completion rate below target',
      actionRequired: 'Optimize route planning and scheduling'
    });
  }
};

analyticsSchema.methods.generateRecommendations = function() {
  this.recommendations = [];
  
  if (this.routeMetrics.fuelConsumption > 0 && this.routeMetrics.routeEfficiency < 85) {
    this.recommendations.push({
      category: 'route_optimization',
      priority: 'high',
      description: 'Implement AI-based route optimization to reduce fuel consumption and improve efficiency',
      expectedImpact: 'Reduce fuel costs by 15-20% and improve collection efficiency',
      implementationCost: 50000,
      timeframe: '3-6 months'
    });
  }
  
  if (this.wasteMetrics.recyclingRate < 30) {
    this.recommendations.push({
      category: 'environmental',
      priority: 'medium',
      description: 'Launch comprehensive recycling education program',
      expectedImpact: 'Increase recycling rate by 10-15%',
      implementationCost: 25000,
      timeframe: '6-12 months'
    });
  }
};

analyticsSchema.virtual('reportPeriodDays').get(function() {
  const timeDiff = this.dateRange.endDate - this.dateRange.startDate;
  return Math.ceil(timeDiff / (1000 * 60 * 60 * 24));
});

analyticsSchema.index({ reportId: 1 });
analyticsSchema.index({ reportType: 1 });
analyticsSchema.index({ generatedBy: 1 });
analyticsSchema.index({ 'dateRange.startDate': 1, 'dateRange.endDate': 1 });
analyticsSchema.index({ status: 1 });
analyticsSchema.index({ createdAt: -1 });

module.exports = mongoose.model('Analytics', analyticsSchema);